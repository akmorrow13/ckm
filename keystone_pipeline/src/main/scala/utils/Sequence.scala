package utils

import breeze.linalg.DenseVector
import workflow.Transformer

/**
 * A wrapper trait for images that might be stored in various ways.  Be warned
 * that using this wrapper probably introduces some inefficiency.  Also, images
 * are currently treated as immutable, which may introduce a serious
 * performance problem; in the future we may need to add a set() method.
 *
 * If you have a choice and performance matters to you, use
 * ChannelMajorArrayVectorizedImage, as it is likely to be the most efficient
 * implementation.
 */
trait Sequence {

  val metadata: SequenceMetadata

  /**
   * Get thevalue at (x, y, channelIdx).  Channels are indexed as
   * follows:
   *   - If the sequence is genomic, 0 => A, 1 => T, 2 => G, 3 => C
   *   - If the seuquence is string, 0 => A, 1 => B, etc.
   */
  def get(x: Int, channelIdx: Int): Double

  /**
   * Put a character value at (x, channelIdx).
   */
  def put(x: Int, channelIdx: Int, newVal: Double)

  /**
   * Returns a flat version of the sequence, represented as a single array.
   * It is indexed as follows: The character value for (x, channelIdx)
   * is at channelIdx + x*numChannels.
   *
   * TODO: This is inefficient. Can remove for loop.
   *
   */
  def toArray: Array[Double] = {
    val flat = new Array[Double](this.flatSize)

    var x = 0
    while (x < this.metadata.dim) {
      val runningOffsetX = x*this.metadata.numChannels
      var channelIdx = 0
      while (channelIdx < this.metadata.numChannels) {
        flat(channelIdx + runningOffsetX) = get(x, channelIdx)
        channelIdx += 1
      }
      x += 1
    }
    flat
  }

  def flatSize: Int = {
    metadata.numChannels*metadata.dim
  }


  /**
   * An inefficient implementation of equals().  Subclasses should override
   * this if they can implement it more cheaply and anyone cares about such
   * things.
   * TODO: Alyssa you dont need a forloop here, could be more efficient
   */
  override def equals(o: Any): Boolean = {
    if (o == null || !o.isInstanceOf[Sequence]) {
      false
    } else {
      val other = o.asInstanceOf[Sequence]
      if (!this.metadata.equals(other.metadata)) {
        false
      } else {
        for(i <- 0 to this.metadata.dim) {
          for(j <- 0 to this.metadata.numChannels) {
            if (this.get(i,j) != other.get(i,j)) {
              return false
            }
          }
        }
        true
      }
    }
  }
}

/**
 * Contains metadata about the storage format of a sequence.
 *
 * @param dim is the length of the sequence
 * @param numChannels is the number of possible characters in the sequence
 */
case class SequenceMetadata(dim: Int, numChannels: Int)


/**
 * VectorizedImage which is indexed as follows: The pixel value for
 * (x, y, channelIdx) is at x + y*xDim + channelIdx*xDim*yDim.
 */
case class RowMajorArrayVectorizedSequence(
                                            vectorizedSequence: Array[Double],
                                            override val metadata: SequenceMetadata) extends VectorizedSequence {
  override def sequenceToVectorCoords(x: Int, channelIdx: Int): Int = {
    x * metadata.numChannels + channelIdx // TODO: Alyssa
  }

  override def vectorToSequenceCoords(v: Int): Coordinate = {
    coord.channelIdx = v % (metadata.numChannels)
    coord.x = v / metadata.numChannels
    coord
  }

  override def getInVector(vectorIdx: Int) = {
    if (vectorIdx >= vectorizedSequence.length) {
       println(vectorizedSequence, vectorIdx)
    }
    vectorizedSequence(vectorIdx)
  }

  override def putInVector(vectorIdx: Int, newVal: Double) = {
    vectorizedSequence(vectorIdx) = newVal
  }
}


/**
 * Wraps a byte array, where a byte is a color channel value.  This is the
 * format generated by Java's JPEG parser.
 *
 * VectorizedImage is indexed as follows: The pixel value for (x, y, channelIdx)
 *   is at channelIdx + y*numChannels + x*numChannels*yDim.
 */
case class ByteArrayVectorizedSequence(
                                     vectorizedSequence: Array[Byte],
                                     val metadata: SequenceMetadata) extends VectorizedSequence {
  def sequenceToVectorCoords(x: Int, channelIdx: Int): Int = {
    channelIdx + x*metadata.dim*metadata.numChannels // TODO: Alyssa
  }

  def vectorToSequenceCoords(v: Int): Coordinate = {
    coord.x = v / (metadata.dim * metadata.numChannels)
    coord.channelIdx = v - coord.x * metadata.numChannels
    coord
  }

  // FIXME: This is correct but inefficient - every time we access the image we
  // use several method calls (which are hopefully inlined) and a conversion
  // from byte to double (which hopefully at least does not involve any
  // boxing).
  override def getInVector(vectorIdx: Int) = {
    val signedValue = vectorizedSequence(vectorIdx)
    if (signedValue < 0) {
      signedValue + 256 // TODO Alyssa: what does this do?
    } else {
      signedValue
    }
  }

  override def putInVector(vectorIdx: Int, newVal: Double) = ???
}

class Coordinate(var x: Int, var channelIdx: Int)
class CoordinateValue(var x: Int, var channelIdx: Int, var v: Double)

/**
 * A labeled image. Commonly used in Image classification.
 *
 * @param sequence A Sequence.
 * @param label A label. Should be in [0 .. K] where K is some number of unique labels.
 */
case class LabeledSequence(sequence: Sequence, label: Double, filename: Option[String] = None)

/**
 * Helper trait for implementing Sequences that wrap vectorized representations
 * of images.
 */
trait VectorizedSequence extends Sequence {
  def sequenceToVectorCoords(x: Int, channelIdx: Int): Int

  def getInVector(vectorIdx: Int): Double

  def putInVector(vectorIdx: Int, newVal: Double): Unit

  override def get(x: Int, channelIdx: Int) = {
    getInVector(sequenceToVectorCoords(x, channelIdx))
  }

  override def put(x: Int, channelIdx: Int, newVal: Double) = {
    putInVector(sequenceToVectorCoords(x, channelIdx), newVal)
  }

  def vectorToSequenceCoords(v: Int): Coordinate

  @transient lazy protected val coord: Coordinate = new Coordinate(0,0)

  /**
   * Returns an iterator of coordinate values based on the "natural" order
   * of a Vectorized image. That is, this returns a value of the form (x,y,channel,value)
   * in order.
   *
   * This method is optimized to avoid unnecessary memory allocation and designed
   * to approach the performance of an equivalent `while` loop over the image pixels for
   * speeding up things like Aggregation over an image regardless of underlying image ordering.
   *
   * An important restriction is that the reference to the returned `CoordinateValue`
   * should not be modified or saved by the caller.
   *
   * @return
   */
  def iter(): Iterator[CoordinateValue] = new Iterator[CoordinateValue] {
    var i = 0
    val totSize = metadata.dim*metadata.numChannels
    var tup: Coordinate = null
    var v: Double = 0.0
    var cv: CoordinateValue = new CoordinateValue(0,0,0.0)

    def hasNext = i < totSize

    def next() = {
      tup = vectorToSequenceCoords(i)
      v = getInVector(i)
      i += 1
      cv.x = tup.x
      cv.channelIdx = tup.channelIdx
      cv.v = v
      cv
    }
  }
}

/**
 * Takes an sequence and converts it to a dense vector.
 */
object SequenceVectorizer extends Transformer[Sequence, DenseVector[Double]] {
  def apply(in: Sequence): DenseVector[Double] = {
    DenseVector(in.toArray)
  }
}



/**
 * Extracts a label from a labeled image.
 */
object LabelExtractor extends Transformer[LabeledSequence, Double] {
  def apply(in: LabeledSequence): Double = in.label
}

/**
 * Extracts an image from a labeled image.
 */
object SequenceExtractor extends Transformer[LabeledSequence, Sequence] {
  def apply(in: LabeledSequence): Sequence = in.sequence
}

/**
 * VectorizedImage that indexed as follows: The pixel value for
 * (x, y, channelIdx) is at channelIdx + x*numChannels + y*numChannels*xDim.
 */
case class ChannelMajorArrayVectorizedSequence(
                                             vectorizedSequence: Array[Double],
                                             override val metadata: SequenceMetadata) extends VectorizedSequence {
  override def sequenceToVectorCoords(x: Int, channelIdx: Int): Int = {
    channelIdx + x * metadata.numChannels
  }

  override def vectorToSequenceCoords(v: Int): Coordinate = {
    coord.x = v / (metadata.dim * metadata.numChannels)
    coord.channelIdx = v - coord.x * metadata.numChannels
    coord
  }

  override def getInVector(vectorIdx: Int) = vectorizedSequence(vectorIdx)


  override def putInVector(vectorIdx: Int, newVal: Double) = {
    vectorizedSequence(vectorIdx) = newVal
  }

  override def toArray = vectorizedSequence
}




